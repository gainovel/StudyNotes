# 2023/11/10 20:06:25🏳️‍🌈

# markdown tree🏳️‍🌈

```text
├── ❌第06章_索引的数据结构
│   ├── ❌1. 为什么使用索引
│   ├── ❌2. 索引及其优缺点
│   │   ├── ❌2.1 索引概述
│   │   ├── ❌2.2 优点
│   │   └── ❌2.3 缺点
│   ├── ❌3. InnoDB中索引的推演
│   │   ├── ❌3.1 索引之前的查找
│   │   │   ├── ❌1. 在一个页中的查找
│   │   │   └── ❌2. 在很多页中查找
│   │   ├── ❌3.2 设计索引
│   │   │   ├── ❌1. 一个简单的索引设计方案
│   │   │   └── ❌2. InnoDB中的索引方案
│   │   │       ├── ❌① 迭代1次：目录项纪录的页
│   │   │       ├── ❌② 迭代2次：多个目录项纪录的页
│   │   │       ├── ❌③ 迭代3次：目录项记录页的目录页
│   │   │       └── ❌④ B+Tree
│   │   ├── ❌3.3 常见索引概念
│   │   │   ├── ❌1. 聚簇索引
│   │   │   ├── ❌2. 二级索引（辅助索引、非聚簇索引）
│   │   │   └── ❌3.联合索引
│   │   └── ❌3.4 InnoDB的B+树索引的注意事项
│   │       ├── ❌1. 根页面位置万年不动
│   │       ├── ❌2. 内节点中目录项记录的唯一性
│   │       └── ❌3. 一个页面最少存储 2 条记录
│   ├── ❌4. MyISAM中的索引方案
│   │   ├── ❌4.1 MyISAM索引的原理
│   │   └── ❌4.2 MyISAM 与 InnoDB对比
│   ├── ❌5. 索引的代价
│   └── ❌6. MySQL数据结构选择的合理性
│       ├── ❌6.1 全表查询
│       ├── ❌6.2 Hash查询
│       ├── ❌6.3 二叉搜索树
│       ├── ❌6.4 AVL树
│       ├── ❌6.5 B-Tree
│       ├── ❌6.6 B+Tree
│       ├── ❌6.7 R树
│       ├── ❌6.8 小结
│       └── ❌附录：算法的时间复杂度
├── ❌第7章_InnoDB数据存储结构
│   ├── ❌1. 数据库的存储结构：页
│   │   ├── ❌1.1 磁盘与内存交互基本单位：页
│   │   ├── ❌1.2 页结构概述
│   │   ├── ❌1.3 页的大小
│   │   └── ❌1.4 页的上层结构
│   ├── ❌2. 页的内部结构
│   │   ├── ❌第一部分：File Header (文件头部) 和 File Trailer (文件尾部)
│   │   ├── ❌第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)
│   │   ├── ❌第三部分：Page Directory (页目录) 和 Page Header (页面头部)
│   │   └── ❌2.3 从数据库页的角度看B+树如何查询
│   ├── ❌3. InnoDB行格式 (或记录格式)
│   ├── ❌4. 区、段与碎片区
│   │   ├── ❌4.1 为什么要有区？
│   │   ├── ❌4.2 为什么要有段？
│   │   ├── ❌4.3 为什么要有碎片区？
│   │   └── ❌4.4 区的分类
│   ├── ❌5. 表空间
│   │   ├── ❌5.1 独立表空间
│   │   └── ❌5.2 系统表空间
│   └── ❌附录：数据页加载的三种方式
├── ❌第8章_索引的创建与设计原则
│   ├── ❌1. 索引的声明与使用
│   │   ├── ❌1.1 索引的分类
│   │   ├── ❌1.2 创建索引
│   │   │   ├── ❌1. 创建表的时候创建索引
│   │   │   └── ❌2. 在已经存在的表上创建索引
│   │   └── ❌1.3 删除索引
│   └── ❌2. MySQL8.0索引新特性
│       ├── ❌2.1 支持降序索引
│       └── ❌2.2 隐藏索引
├── ❌调用
│   ├── ❌3. 索引的设计原则
│   │   └── ❌3.1 数据准备
│   └── t global log_bin_trust_function_creators=1; # ❌不加global只是当前窗口有效。
│       ├── ❌3.2 哪些情况适合创建索引
│       │   ├── ❌1. 字段的数值有唯一性的限制
│       │   ├── ❌2. 频繁作为 WHERE 查询条件的字段
│       │   ├── ❌3. 经常 GROUP BY 和 ORDER BY 的列
│       │   ├── ❌4. UPDATE、DELETE 的 WHERE 条件列
│       │   ├── ❌5.DISTINCT 字段需要创建索引
│       │   ├── ❌6. 多表 JOIN 连接操作时，创建索引注意事项
│       │   ├── ❌7. 使用列的类型小的创建索引
│       │   ├── ❌8. 使用字符串前缀创建索引
│       │   ├── ❌9. 区分度高(散列性高)的列适合作为索引
│       │   ├── ❌10. 使用最频繁的列放到联合索引的左侧
│       │   └── ❌11. 在多个字段都要创建索引的情况下，联合索引优于单值索引
│       ├── ❌3.3 限制索引的数目
│       └── ❌3.4 哪些情况不适合创建索引
│           ├── ❌1. 在where中使用不到的字段，不要设置索引
│           ├── ❌2. 数据量小的表最好不要使用索引
│           ├── ❌3. 有大量重复数据的列上不要建立索引
│           ├── ❌4.  避免对经常更新的表创建过多的索引
│           ├── ❌5. 不建议用无序的值作为索引
│           ├── ❌6. 删除不再使用或者很少使用的索引
│           └── ❌7. 不要定义夯余或重复的索引
├── ❌存储过程1：创建插入课程表存储过程
├── ❌存储过程2：创建插入学生信息表存储过程
├── ❌第09章_性能分析工具的使用
│   ├── ❌1. 数据库服务器的优化步骤
│   ├── ❌2. 查看系统性能参数
│   ├── ❌3. 统计SQL的查询成本: last_query_cost
│   ├── ❌4. 定位执行慢的 SQL：慢查询日志
│   │   └── ❌4.1 开启慢查询日志参数
│   ├── ow_query_log=ON  # ❌开启慢查询日志开关
│   ├── ow_query_log_file=/var/lib/mysql/atguigu-low.log  # ❌慢查询日志的目录和文件名信息
│   ├── ng_query_time=3  # ❌设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
│   │   ├── ❌4.2 查看慢查询数目
│   │   └── ❌4.3 案例演示
│   └── t global log_bin_trust_function_creators=1; # ❌不加global只是当前窗口有效。
│       ├── ❌4.4 测试及分析
│       └── ❌4.5 慢查询日志分析工具：mysqldumpslow
├── ❌测试
│   ├── oot@bogon ~]# ❌mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log
│   │   ├── ❌4.6 关闭慢查询日志
│   │   └── ❌4.7 删除慢查询日志
│   ├── ❌5. 查看 SQL 执行成本：SHOW PROFILE
│   ├── ❌6. 分析查询语句：EXPLAIN
│   │   ├── ❌6.1 概述
│   │   ├── ❌6.2 基本语法
│   │   └── ❌6.3 数据准备
│   └── t global log_bin_trust_function_creators=1; # ❌不加global只是当前窗口有效。
│       └── ❌6.4 EXPLAIN各列作用
│           ├── ❌1. table
│           ├── ❌2. id
│           ├── ❌3. select_type
│           ├── ❌ 4. partitions (可略)
│           ├── ❌5. type ☆
│           ├── ❌ 6. possible_keys和key
│           ├── ❌7. key_len ☆
│           ├── ❌8. ref
│           ├── ❌9. rows ☆
│           ├── ❌10. filtered
│           ├── ❌11. Extra ☆
│           └── ❌12. 小结
├── ❌查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。
├── ❌Union去重
│   ├── ❌7. EXPLAIN的进一步使用
│   │   └── ❌7.1 EXPLAIN四种输出格式
│   │       ├── ❌1. 传统格式
│   │       ├── ❌2. JSON格式
│   │       ├── ❌3. TREE格式
│   │       └── ❌4. 可视化输出
│   ├── �们使用 # ❌后边跟随注释的形式为大家解释了 `EXPLAIN FORMAT=JSON` 语句的输出内容，但是大家可能 有疑问 "`cost_info`" 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 "`cost_info`" 部 分 
：
│   │   └── ❌7.2 SHOW WARNINGS的使用
│   ├── ❌8. 分析优化器执行计划：trace
│   └── ❌9. MySQL监控分析视图-sys schema
│       ├── ❌9.1 Sys schema视图摘要
│       └── ❌9.2 Sys schema视图使用场景
├── ❌1. 查询表的访问量
├── ❌2. 查询占用bufferpool较多的表
├── ❌3. 查看表的全表扫描情况
│   └── ❌10. 小结
├── ❌第10章_索引优化与查询优化
│   ├── ❌1. 数据准备
│   ├── t global log_bin_trust_function_creators=1; # ❌不加global只是当前窗口有效。
│   └── ❌2. 索引失效案例
│       ├── ❌2.1 全值匹配我最爱
│       ├── ❌2.2 最佳左前缀法则
│       ├── ❌2.3 主键插入顺序
│       ├── ❌2.4 计算、函数、类型转换(自动或手动)导致索引失效
│       ├── ❌2.5 类型转换导致索引失效
│       ├── ❌2.6 范围条件右边的列索引失效
│       ├── ❌2.7 不等于(!= 或者<>)索引失效
│       ├── ❌ 2.8 is null可以使用索引，is not null无法使用索引
│       ├── ❌2.9 like以通配符%开头索引失效
│       ├── ❌2.10 OR 前后存在非索引的列，索引失效
│       ├── ❌2.11 数据库和表的字符集统一使用utf8mb4
│       └── ❌2.12 练习及一般性建议
├── ❌未使用到索引
├── ❌使用到索引
├── ❌未使用到索引
│   └── ❌3. 关联查询优化
│       ├── ❌3.1 数据准备
│       ├── ❌3.2 采用左外连接
│       ├── ❌3.3 采用内连接
│       └── ❌3.4 join语句原理
│           ├── ❌1. 驱动表和被驱动表
│           ├── ❌2. Simple Nested-Loop Join (简单嵌套循环连接)
│           ├── ❌3. Index Nested-Loop Join （索引嵌套循环连接）
│           ├── ❌4. Block Nested-Loop Join（块嵌套循环连接）
│           ├── ❌5. Join小结
│           └── ❌6. Hash Join
├── ❌分类
├── ❌或
├── ❌测试1
├── ❌测试2
│   ├── lect t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id<=100; # ❌推荐
│   ├── lect t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id<=100; # ❌不推荐
│   │   └── ❌3.5 小结
│   └── ❌4. 子查询优化
├── ❌创建班级表中班长的索引
│   └── ❌5. 排序优化
│       ├── ❌5.1 排序优化
│       ├── ❌5.2 测试
│       ├── ❌5.3 案例实战
│       └── ❌5.4 filesort算法：双路排序和单路排序
├── ❌方式1
├── ❌方式2
│   ├── ❌6. GROUP BY优化
│   ├── ❌7. 优化分页查询
│   └── ❌8. 优先考虑覆盖索引
│       ├── ❌8.1 什么是覆盖索引？
│       └── ❌8.2 覆盖索引的利弊
├── ❌删除之前的索引
│   ├── ❌9. 如何给字符串添加索引
│   │   ├── ❌9.1 前缀索引
│   │   └── ❌9.2 前缀索引对覆盖索引的影响
│   └── ❌10. 索引下推
│       ├── ❌10.1 使用前后对比
│       ├── ❌10.2 ICP的开启/关闭
│       ├── ❌10.3 ICP使用案例
│       ├── ❌10.4 开启和关闭ICP性能对比
│       └── ❌10.5 ICP的使用条件
├── ❌打开索引下推
├── ❌关闭索引下推
│   ├── ❌11. 普通索引 vs 唯一索引
│   │   ├── ❌11.1 查询过程
│   │   ├── ❌11.2 更新过程
│   │   └── ❌11.3 change buffer的使用场景
│   ├── ❌12. 其它查询优化策略
│   │   ├── ❌12.1 EXISTS 和 IN 的区分
│   │   ├── ❌12.2 COUNT(*)与COUNT(具体字段)效率
│   │   ├── ❌12.3 关于SELECT(*)
│   │   ├── ❌12.4 LIMIT 1 对优化的影响
│   │   └── ❌12.5 多使用COMMIT
│   └── ❌13. 淘宝数据库，主键如何设计的？
│       ├── ❌13.1 自增ID的问题
│       ├── ❌13.2 业务字段做主键
│       ├── ❌13.3 淘宝的主键设计
│       └── ❌13.4 推荐的主键设计
├── ❌第11章_数据库的设计规范
│   ├── ❌1. 为什么需要数据库设计
│   ├── ❌2. 范 式
│   │   ├── ❌2.1 范式简介
│   │   ├── ❌2.2 范式都包括哪些
│   │   ├── ❌2.3 键和相关属性的概念
│   │   ├── ❌2.4 第一范式(1st NF)
│   │   ├── ❌2.5 第二范式(2nd NF)
│   │   ├── ❌2.6 第三范式(3rd NF)
│   │   └── ❌2.7 小结
│   ├── ❌3. 反范式化
│   │   ├── ❌3.1 概述
│   │   ├── ❌3.2 应用举例
│   │   ├── ❌3.3 反范式的新问题
│   │   └── ❌3.4 反范式的适用场景
│   │       ├── ❌1. 增加冗余字段的建议
│   │       └── ❌2. 历史快照、历史数据的需要
│   ├── ❌4. BCNF(巴斯范式)
│   ├── ❌5. 第四范式
│   ├── ❌6. 第五范式、域键范式
│   ├── ❌7. 实战案例
│   │   ├── ❌7.1 迭代1次：考虑1NF
│   │   ├── ❌7.2 迭代2次：考虑2NF
│   │   ├── ❌7.3 迭代3次：考虑3NF
│   │   └── ❌7.4 反范式化：业务优先的原则
│   ├── ❌8. ER模型
│   │   ├── ❌8.1 ER模型包括哪些要素？
│   │   ├── ❌8.2 关系的类型
│   │   ├── ❌8.3 建模分析
│   │   ├── ❌8.4 ER 模型的细化
│   │   └── ❌8.5 ER 模型图转换成数据表
│   │       ├── ❌1. 一个实体转换成一个数据库
│   │       ├── ❌2. 一个多对多的关系转换成一个数据表
│   │       ├── ❌3. 通过外键来表达1对多的关系
│   │       └── ❌4. 把属性转换成表的字段
│   ├── ❌9. 数据表的设计原则
│   ├── ❌10. 数据库对象编写建议
│   │   ├── ❌10.1 关于库
│   │   ├── ❌10.2 关于表、列
│   │   ├── ❌10.3 关于索引
│   │   └── ❌10.4 SQL编写
│   └── ❌11. PowerDesigner的使用
│       ├── ❌11.1 开始界面
│       ├── ❌11.2 概念数据模型
│       ├── ❌11.3 物理数据模型
│       ├── ❌11.4 概念模型转为物理模型
│       ├── ❌11.5 物理模型转为概念模型
│       └── ❌ 11.6 物理模型导出SQL语句
└── ❌第12章_数据库其它调优策略
    ├── ❌1. 数据库调优的措施
    │   ├── ❌1.1 调优的目标
    │   ├── ❌1.2 如何定位调优问题
    │   └── ❌1.3 调优的维度和步骤
    │       ├── ❌第1步：选择适合的 DBMS
    │       ├── ❌第2步：优化表设计
    │       ├── ❌第3步：优化逻辑查询
    │       ├── ❌第4步：优化物理查询
    │       ├── ❌第5步：使用 Redis 或 Memcached 作为缓存
    │       └── ❌第6步：库级优化
    ├── ❌2. 优化MySQL服务器
    │   ├── ❌2.1 优化服务器硬件
    │   └── ❌2.2 优化MySQL的参数
    ├── ❌3. 优化数据库结构
    │   ├── ❌3.1 拆分表：冷热数据分离
    │   ├── ❌3.2 增加中间表
    │   ├── ❌3.3 增加冗余字段
    │   ├── ❌3.4 优化数据类型
    │   ├── ❌3.5 优化插入记录的速度
    │   ├── ❌3.6 使用非空约束
    │   └── ❌3.7 分析表、检查表与优化表
    │       ├── ❌1. 分析表
    │       ├── ❌2. 检查表
    │       ├── ❌3. 优化表
    │       └── ❌3.8 小结
    ├── ❌4. 大表优化
    │   ├── ❌4.1 限定查询的范围
    │   ├── ❌ 4.2 读/写分离
    │   ├── ❌4.3 垂直拆分
    │   └── ❌4.4 水平拆分
    └── ❌5. 其它调优策略
        ├── ❌5.1 服务器语句超时处理
        ├── ❌5.2 创建全局通用表空间
        └── ❌5.3 MySQL 8.0新特性：隐藏索引对调优的帮助

```